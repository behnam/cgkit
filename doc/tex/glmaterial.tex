% GLMaterial

\section{\class{GLMaterial} ---
         OpenGL material}

The \class{GLMaterial} class represents the material model of the standard
OpenGL API. All colors are represented as (r,g,b,a). If you don't use
blending you can leave out the alpha value in the constructor.

\begin{classdesc}{GLMaterial}{name = "GLMaterial",\\ 
                              ambient = (0.2, 0.2, 0.2, 1.0),\\
                              diffuse = (0.7, 0.7, 0.7, 1.0),\\
                              specular = (0, 0, 0, 1),\\
                              shininess = 0.0,\\
                              emission = (0, 0, 0, 1),\\
                              blend_factors = None,\\
                              texture = None,\\
                              vertex_shader = None,\\
                              fragment_shader = None,\\
                              density = 1.0}

\var{ambient} is the ambient color of the material.

\var{diffuse} is the diffuse color of the material.

\var{specular} is the color of the specular highlight.

\var{shininess} determines the size of the highlight and lies 
between 0.0 and 128.0. The higher the value, the smaller and brighter
the highlight.

The \var{emission} color can be used to simulate objects that emit light.

\var{blend_factors} is a 2-tuple with the parameters for the 
\cfunction{glBlendFunc()} call which indicate how to compute the
source and destination blend factors 
(see \ulink{\cfunction{glBlendFunc()}}{http://pyopengl.sourceforge.net/documentation/manual/glBlendFunc.3G.html}).
Blending is disabled if \var{blend_factors} is \code{None}.

\var{texture} is either \code{None}, a single \class{GLTexture} object or
a list of \class{GLTexture} objects specifying the texture image(s) to use.

\var{vertex_shader} is either \code{None}, a single \class{GLShader} object
or a list of \class{GLShader} objects specifying the vertex shaders to use.

\var{fragment_shader} is either \code{None}, a single \class{GLShader} object
or a list of \class{GLShader} objects specifying the fragment shaders to use.

\var{density} is the density value used for physical simulations.
\end{classdesc}

% Methods
\begin{methoddesc}{getNumTextures}{}
Return the current size of the texture array.
\end{methoddesc}

\begin{methoddesc}{setNumTextures}{num}
Set a new size for the texture array.
\end{methoddesc}

\begin{methoddesc}{getTexture}{idx=0}
Get a stored texture. The method returns \code{None} if the given index
is out of range or if there is no texture stored at that position.
\end{methoddesc}

\begin{methoddesc}{setTexture}{tex, idx=0}
Set a new texture. An \exception{IndexError} exception is thrown if the 
index is out of range.
\end{methoddesc}

\begin{methoddesc}{getNumVertexShaders}{}
Return the current size of the vertex shader array.
\end{methoddesc}

\begin{methoddesc}{setNumVertexShaders}{num}
Set a new size for the vertex shader array.
\end{methoddesc}

\begin{methoddesc}{getVertexShader}{idx=0}
Get a vertex shader object. The method returns \code{None} if the given index
is out of range or if there is no shader object stored at that position.
\end{methoddesc}

\begin{methoddesc}{setVertexShader}{shader, idx=0}
Set a new vertex shader object. An \exception{IndexError} exception is 
thrown if the index is out of range. A ValueError exception is thrown if the 
shader is not of type \code{VERTEX}.
\end{methoddesc}

\begin{methoddesc}{getNumFragmentShaders}{}
Return the current size of the fragment shader array.
\end{methoddesc}

\begin{methoddesc}{setNumFragmentShaders}{num}
Set a new size for the fragment shader array.
\end{methoddesc}

\begin{methoddesc}{getFragmentShader}{idx=0}
Get a fragment shader object. The method returns \code{None} if the given index
is out of range or if there is no shader object stored at that position.
\end{methoddesc}

\begin{methoddesc}{setFragmentShader}{shader, idx=0}
Set a new fragment shader object. An \exception{IndexError} exception is 
thrown if the index is out of range. A ValueError exception is thrown if the 
shader is not of type \code{FRAGMENT}.
\end{methoddesc}

%-----------------------
\subsection{\class{GLTexture} --- Specifying a texture map}

The \class{GLTexture} class is used to describe the parameters of an
OpenGL texture map for use with the \class{GLMaterial} class.

\begin{classdesc}{GLTexture}{imagename = "",\\
                             image = None,\\ 
                             mode = GL_DECAL,\\
                             mipmap = True,\\
                             mag_filter = GL_LINEAR,\\
                             min_filter = GL_LINEAR,\\
                             wrap_s = GL_REPEAT,\\
                             wrap_t = GL_REPEAT,\\
                             internalformat = GL_RGB,\\
                             texenvcolor = vec4(1),\\
                             transform = mat4(1),\\
                             size = None, \\
                             environment_map = False\\
                            }

\var{imagename} is the name of the image file that should be used as a
texture map. If the image resolution is not a power of 2, the image
is scaled up to the next higher power of 2 resolution.

It is also possible to pass the actual image data in the \var{image}
parameter.  The image can either be a PIL image or the raw RGB
data. In the latter case, you must explicitly specify the image
resolution (which must then be a power of 2 resolution) in the \var{size}
argument. The \var{imagename} argument is ignored if the data is passed
via the \var{image} argument.

\var{mode} specifies how the image is applied to the object. It can be
one of \code{GL_REPLACE}, \code{GL_MODULATE}, \code{GL_DECAL} and 
\code{GL_BLEND}. In the latter
case, the blend color is given by \var{texenvcolor} 
(see \ulink{\cfunction{glTexEnv()}}{http://pyopengl.sourceforge.net/documentation/manual/glTexEnv.3G.html}).

\var{mipmap} determines whether mip mapping should be used or not.

\var{mag_filter} is the filter to use when magnification occurs (i.e. when
the texture appears larger on screen that it actually is). It can be
either \code{GL_NEAREST} or \code{GL_LINEAR}.

\var{min_filter} is the filter to use when minification occurs (i.e. when
the texture appears smaller on screen that it actually is). It can be one
of following values
(see \ulink{\cfunction{glTexParameter()}}{http://pyopengl.sourceforge.net/documentation/manual/glTexParameter.3G.html}):
%\code{GL_NEAREST}, \code{GL_LINEAR}, \code{GL_NEAREST_MIPMAP_NEAREST},
%\code{GL_NEAREST_MIPMAP_LINEAR}, \code{GL_LINEAR_MIPMAP_NEAREST} or
%\code{GL_LINEAR_MIPMAP_LINEAR}

\begin{itemize}
\item \code{GL_NEAREST}
\item \code{GL_LINEAR}
\item \code{GL_NEAREST_MIPMAP_NEAREST}
\item \code{GL_NEAREST_MIPMAP_LINEAR}
\item \code{GL_LINEAR_MIPMAP_NEAREST}
\item \code{GL_LINEAR_MIPMAP_LINEAR}
\end{itemize}

If \code{GL_LINEAR} is specified and mip mapping
is used then the filter is automatically set to \code{GL_LINEAR_MIPMAP_LINEAR}

\var{wrap_s} and \var{wrap_t} specify what happens if the texture coordinate
leave the range 0-1. They can be one of \code{GL_REPEAT}, \code{GL_CLAMP}
and \code{GL_CLAMP_TO_EDGE}
(see \ulink{\cfunction{glTexParameter()}}{http://pyopengl.sourceforge.net/documentation/manual/glTexParameter.3G.html}).

\var{internalformat} specifies how the image data will be stored in memory.
Usually, you'll either specify \code{GL_RGB} or \code{GL_RGBA} if you have
alpha values in your image and you want to use them
(see \ulink{\cfunction{glTexImage2D()}}{http://pyopengl.sourceforge.net/documentation/manual/glTexImage2D.3G.html}).

\var{transform} is a transformation that is applied to the texture coordinates.

\var{size} is a 2-tuple containing the desired texture map resolution which
must be a power of 2. The image is resized to the specified resolution.
If \var{size} is \code{None} then the next higher power of 2 value is used.

If \var{environment_map} is \code{True} the image is used as a 
latitude/longitude environment map.

\end{classdesc}

%-----------------------
\subsection{\class{GLShader} --- Specifying a shader}

The \class{GLShader} class is used to add a OpenGL 2 shader source file
to a \class{GLMaterial} class.

\begin{classdesc}{GLShader}{shadertype,\\
                            filename,\\ 
                            cpp = None,\\
                            cpperrstream = sys.stderr,\\
                            **shaderparams
                            }

\var{shadertype} specifies whether this shader is vertex shader or a
fragment shader. The value can either be \code{GLShader.ShaderType.VERTEX}
(or \code{GLSLANG_VERTEX}) or \code{GLShader.ShaderType.FRAGMENT}
(or \code{GLSLANG_FRAGMENT}).

\var{filename} is the shader source file name.

\var{cpp} determines the preprocessor that should be used when extracting
shader parameters. \var{cpperrstream} is used to output errors from the
preprocessor (see the function \function{glslangparams.glslangparams()} 
(section \ref{glslangparams}) for details).

Any additional keyword argument is assumed to be a shader parameter.
\end{classdesc}

