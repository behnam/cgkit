\section{\module{cgtypes} ---
         Vectors, matrices and quaternions}

\declaremodule{extension}{cgkit.cgtypes}
\modulesynopsis{Basic types useful for computer graphics.}

This module contains the fundamental types which make working with 3D
data much easier. The types are:

\begin{itemize}
\item vec3 -- a three dimensional vector type to store points, vectors, normals or even colors.
\item vec4 -- a four dimensional vector type to store homogenous points, for example.
\item mat3 -- a 3x3 matrix to store linear transformations.
\item mat4 -- a 4x4 matrix to store affine transformations.
\item quat -- a quaternion type as a specialized way to store rotations.
\end{itemize}

You import all of those types at once with

\begin{verbatim}
from cgkit.cgtypes import *
\end{verbatim}

or you can import them individually like this

\begin{verbatim}
from cgkit.cgtypes import vec3, mat4
\end{verbatim}

In general, you can use those types just as if they were built-in
types which means the mathematical operators can be used and have
their respective meaning. Each type has some additional methods which
are described in the respective documentation.

Here are some examples:

\begin{verbatim}
>>> from cgkit.cgtypes import *
>>> v=vec3(0.5,1.0,-2.5)
>>> print v
(0.5000, 1.0000, -2.5000)
>>> print v.length()
2.73861278753
>>> v=v.normalize()
>>> print v
(0.1826, 0.3651, -0.9129)
>>> print v.length()
1.0
\end{verbatim}

Now let's construct a rotation matrix that rotates points by 90
degrees around the z-axis:

\begin{verbatim}
>>> M=mat4(1).rotate(0.5*math.pi, vec3(0,0,1))
\end{verbatim}

and apply the rotation to the vector (1,0,0) (the x-axis):

\begin{verbatim}
>>> print M*vec3(1,0,0)
(0.0000, 1.0000, 0.0000)
\end{verbatim}

The module contains the following functions:

\begin{funcdesc}{getEpsilon}{}
Return the epsilon threshold which is used for doing comparisons.
\end{funcdesc}

\begin{funcdesc}{setEpsilon}{eps}
Sets a new epsilon threshold and returns the previously set value. Two
values are considered to be equal if their absolute difference is less
than or equal to epsilon.
\end{funcdesc}

\begin{funcdesc}{slerp}{t, q0, q1, shortest=True}
Performs a spherical linear interpolation between two quaternions \var{q0}
and \var{q1}. For \var{t}=0.0 the return value equals \var{q0}, for 
\var{t}=1.0 it equals \var{q1}. \var{q0} and \var{q1} must be unit 
quaternions. If \var{shortest} is \code{True} the interpolation will always
be along the shortest path, otherwise it depends on the orientation of
the input quaternions whether the shortest or longest path will be taken
(you can switch between the paths by negating either \var{q0} or \var{q1}).
\end{funcdesc}

\begin{funcdesc}{squad}{t, a, b, c, d}
Performs a spherical cubic interpolation between quaternion \var{a} and \var{d}
where quaternion \var{b} and \var{c} define the shape of the interpolation
curve. For \var{t}=0.0 the return value equals \var{a}, for \var{t}=1.0 it 
equals \var{d}. All quaternions must be unit quaternions.
\end{funcdesc}

%----------------------------------------------------------------------
\input{vec3.tex}

%----------------------------------------------------------------------
\input{vec4.tex}

%----------------------------------------------------------------------
\input{mat3.tex}

%----------------------------------------------------------------------
\input{mat4.tex}

%----------------------------------------------------------------------
\input{quat.tex}
