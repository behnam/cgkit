\section{\module{slparams} ---
          Extracting RenderMan Shader parameters}
\label{slparams}

\declaremodule{extension}{cgkit.slparams}
\modulesynopsis{Extracting RenderMan Shader parameters}

This module can be used to extract the parameters of a RenderMan
shader either from the shader source file or from the compiled shader.
To read parameters from a compiled shader it is necessary that the renderer
package is installed that was used to compile the shader. Currently, the
following renderers are supported:

\begin{itemize}
  \item 3Delight 
  \item Aqsis
  \item Pixie
  \item PRMan
\end{itemize}

Other renderers can be added at runtime (see the \module{sloargs} module).

\begin{funcdesc}{slparams}{slfile, cpp=None, cpperrstream=sys.stderr, includedirs=None, defines=None}
Extracts the shader parameters from a Shading Language source file. 

The argument \var{slfile} is either the name of a compiled shader, the
name of the shader source file (*.sl) or a file-like object that provides the
shader sources.

\var{cpp} determines how the shader source is preprocessed. It can be
either a string containing the name of an external preprocessor tool
(such as \code{cpp}) that must take the file name as parameter and
dump the preprocessed output to stdout. If the preprocessor does not
produce any data a \exception{PreprocessorNotFound} exception is
thrown. The error stream of the preprocessor is written to the object
that is specified by \var{cpperrstream} which must have a
\method{write()} method. If \var{cpperrstream} is \code{None}, the error 
stream is ignored. \var{cpp} can also be a callable object that takes a
filename as input and returns the filtered contents as a string. If
\var{cpp} is \code{None} a simple internal preprocessor based on the 
\module{simplecpp} module is used.

\var{includedirs} is a list of strings that contain directories where to 
look for include files. \var{defines} is a list of tuples (\var{name},
\var{value}) that specify the predefined symbols to use.

The function returns a list of shader info objects. These objects have
four attributes:
    
\begin{itemize}
  \item \var{type}: The type of the shader (\code{"surface"},
  \code{"displacement"}, etc.)
  \item \var{name}: The name of the shader
  \item \var{params}: The shader parameters (see below)
  \item \var{meta}: The shader meta data. How exactly meta data is specified
  depends on the renderer you are using.
\end{itemize}
     
The parameters are given as a list of shader parameter objects describing each
parameter. A shader parameter object has the following attributes:

\begin{itemize}
\item \var{outputSpec}: The output specifier (either \code{"output"} or an empty
string)
\item \var{storage}: The storage class (\code{"uniform"} or \code{"varying"}) 
\item \var{type}: The parameter type 
\item \var{size}: The array length or \code{None} if the parameter is not
an array
\item \var{name}: The name of the parameter 
\item \var{space}: The space in which a point-like type or a color was
defined. If the parameter is an array then this is also an array of space names.
\item \var{default}: The default value (always given as a string)
\end{itemize}

For backwards compatibility, the shader info object behaves like a
3-tuple (\var{type}, \var{name}, \var{params}). The meta data can only be
accessed via name though. The shader parameter objects can also be used
like 7-tuples containing the above data (in the order given above).

Example (output slightly reformatted for better readability):
 
\begin{verbatim}
>>> from cgkit import slparams
>>> shaders = lparams.slparams("plastic.sl")
>>> print shaders
[('surface', 'plastic', 
  [('', 'uniform', 'float', None, 'Ka', None, '1'),
   ('', 'uniform', 'float', None, 'Kd', None, '0.5'),
   ('', 'uniform', 'float', None, 'Ks', None, '0.5'),
   ('', 'uniform', 'float', None, 'roughness', None, '0.1'),
   ('', 'uniform', 'color', None, 'specularcolor', 'rgb', '1')])]
>>> shaders[0].type
'surface'
>>> shaders[0].name
'plastic'
>>> for param in shaders[0].params: print param.name
... 
Ka
Kd
Ks
roughness
specularcolor
>>> shaders[0].meta
{}
\end{verbatim}

The parser used inside this function was generated using the parser
generator \ulink{Yapps}{http://theory.stanford.edu/\~{}amitp/Yapps/} 
by Amit Patel.
\end{funcdesc}

\begin{funcdesc}{convertdefault}{paramtuple}
Converts the default value of a shader parameter into a Python
type. The argument \var{paramtuple} must be a 7-tuple (or parameter object) as
returned by \function{slparams()}. The function returns a Python object that corresponds to
the default value of the parameter. If the default value can't be
converted then \code{None} is returned. Only the functions that are
present in the \module{sl} module are evaluated. If a default value
calls a user defined function then \code{None} is returned. The SL
types will be converted into the following Python types:

\begin{tableii}{c|c}{code}{SL type }{ Python type}
\lineii{float}{\code{float}}
\lineii{string}{\code{string}}
\lineii{color}{\code{vec3}}
\lineii{point}{\code{vec3}}
\lineii{vector}{\code{vec3}}
\lineii{normal}{\code{vec3}}
\lineii{matrix}{\code{mat4}}
\end{tableii}

Arrays will be converted into lists of the corresponding type.
\end{funcdesc}

The module defines the following exception classes:

\begin{excdesc}{SLParamsError}
Base class for the exceptions in this module. This class is derived
from the Exception class.
\end{excdesc}

\begin{excdesc}{PreprocessorNotFound}
This exception is thrown when calling the preprocessor didn't produce
any data.
\end{excdesc}

\begin{excdesc}{SyntaxError}
This exception is thrown when a syntax error is found in any function
or shader definition. The exception has the following attributes:

\begin{itemize}
\item \var{filename}: The filename where the error was found 
\item \var{lineno}: The line number where the error was found 
\item \var{line}: The entire line that contains the error 
\item \var{errpos}: The character position where the error token starts
\end{itemize}
\end{excdesc}

\begin{excdesc}{NoMoreTokens}
This exception is thrown when the parser runs out of tokens.
\end{excdesc}
