\section{\module{slots} ---
         Slot classes}

\declaremodule{extension}{cgkit.slots}
\modulesynopsis{Slot classes}

% -------------------------------------------------
\subsection{Dependent class}

\begin{classdesc}{Dependent}{}
\end{classdesc}

\begin{methoddesc}{onValueChanged}{}
Normal/array
\end{methoddesc}

\begin{methoddesc}{onResize}{newsize}
This method is called by a controlling array slot whenever the size of
the slot has changed.
\end{methoddesc}

\begin{methoddesc}{queryResizeVeto}{size}
Check if a dependent vetoes a resize operation. This method is called
by an array slot on all its dependents whenever the slot size should
be changed to \var{size}. If the
method returns \code{True} the resize operation is rejected. The
default implementation returns \code{False}. Only slots with size
constraints should return \code{True}.
\end{methoddesc}


% -------------------------------------------------
\subsection{Slot classes}

There are the following standard slots:

\begin{itemize}
\item DoubleSlot
\item IntSlot
\item BoolSlot
\item StrSlot
\item PySlot
\item Vec3Slot
\item Vec4Slot
\item Mat3Slot
\item Mat4Slot
\item QuatSlot
\end{itemize}

\begin{classdesc}{Slot}{[value, flags]}
  Create a slot that initially carries the specified value.

  Todo: Describe the flags argument.
\end{classdesc}

%\begin{memberdesc}{_value}
%The current slot value.
%\end{memberdesc}

% isSlotCompatible
\begin{methoddesc}{isSlotCompatible}{slot}
Return \code{True} if \var{slot} is compatible with this slot. Two slots are
compatible if they hold the same type of value. Only compatible slots can be
connected to each other. But note that even when this method returns
true, it can happen that the slots can {\it not} be connected. This is the
case whenever the target just doesn't accept input connections (for
example, because it's computing its output value procedurally).
\end{methoddesc}

% typeName
\begin{methoddesc}{typeName}{}
Return a string containing the name of the stored type. This name can
be used to display the type of the slot to the user. The name should
be chosen so that if two slots cannot be connected to each other then
they should also return different names (however, if two slots have
different names it is still possible that they can be connected to each
other).
\end{methoddesc}

% getController
\begin{methoddesc}{getController}{}
Return the associated controlling slot or \code{None}.
\end{methoddesc}

% setController
\begin{methoddesc}{setController}{slot}
Set or remove a controller for this slot.  The current controller is
replaced with \var{slot} which may also be \code{None} to remove the
current controller only. If the controller is not compatible with this
slot an \exception{EIncompatibleSlotTypes} exception is thrown. 
\end{methoddesc}

% getValue
\begin{methoddesc}{getValue}{}
Return the current slot value.
\end{methoddesc}

% setValue
\begin{methoddesc}{setValue}{val}
Set a new value. If the slot has a controller the new value is
propagated up to the controller. It is then up to the controller how
this new value influences the actual output value. So it is not
guaranteed that the output of the slot is really the new value. When
the value really changes this method triggers the onValueChanged() method
on all dependent objects.
\end{methoddesc}

% connect
\begin{methoddesc}{connect}{slot}
Connect the output of this slot with the input of \var{slot}.
Calling this method is equivalent to calling \code{slot.setController(self)}.
The method has no effect if \var{slot} is \code{None}.
\end{methoddesc}

% disconnect
\begin{methoddesc}{disconnect}{slot}
Breaks an existing connection between this slot and \var{slot}.
Calling this method is equivalent to calling \code{slot.setController(None)}.
The method checks if the connection actually exists before breaking it.
If it does not exist, a \exception{ValueError} exception is raised.
The method has no effect if \var{slot} is \code{None}.
\end{methoddesc}

% addDependent
\begin{methoddesc}{addDependent}{d}
Establish a dependency between this slot and another object \var{d}.
The argument \var{d} is added to the list of dependent objects. This
means that \var{d} somehow depends on the value of this slot and that
\var{d} has to be notified whenever the value of this slot changes.
The actual notification is done by calling \method{notifyDependents()}
which in turn calls \method{onValueChanged()} on all dependent objects.

Todo: C++ warning!
\end{methoddesc}

% removeDependent
\begin{methoddesc}{removeDependent}{d}
Remove the dependency between this slot and another object \var{d}.
\end{methoddesc}

% notifyDependents
\begin{methoddesc}{notifyDependents}{}
Notify all dependent slots about a value change. This method calls the
\method{onValueChanged()} method of all slots whose value depends on the 
value of this slot.
\end{methoddesc}

% computeValue
\begin{methoddesc}{computeValue}{}
This method is used to compute a new value whenever \method{getValue()} is
called and the cache is invalid. It should only be implemented on
procedural slots.
\end{methoddesc}

% -------------------------------------------------
\subsection{ArraySlot classes}

\begin{classdesc}{ArraySlot}{multiplicity=1, constraint=None}
Create an array slot.

\var{multiplicity} is the ``array length'' of one individual item.

\var{constraint} is a SizeConstraint object that constrains the size
of the array slot (see section \ref{sizeconstraints}).
\end{classdesc}

% size
\begin{methoddesc}{size}{}
Return the number of elements in this array slot.
\end{methoddesc}

% isResizable
\begin{methoddesc}{isResizable}{size, ignorelocalconstraint=False}
Check if this slot can currently be resized to a particular size.
This method can be used to check if calling \method{resize()} with
\var{size} as argument would succeed or not.

The method returns \code{False} if either the slot itself is size
constrained or it is connected to a size constrained slot. In the
latter case, the function will return \code{True} again if the
connection is removed. The method will also return \code{True} if
\var{size} matches the constraint size.

If \var{ignorelocalconstraint} is \code{True} the method will
compute its result as if there would no constraint be present in this 
slot (so only dependent objects could reject the resize operation).
\end{methoddesc}

% resize
\begin{methoddesc}{resize}{size}
Resize the array slot so that it can carry \var{size} elements.
The values in the array are not modified by this operation.
\end{methoddesc}

% multiplicity
\begin{methoddesc}{multiplicity}{}
Return the multiplicity of the array slot.
\end{methoddesc}

% copyValues
\begin{methoddesc}{copyValues}{begin, end, target, index}
Copies the slice [\var{begin} : \var{end}] into position \var{index}
of the slot \var{target}. 
If you want to copy one single value you have to pass [n, n+1]. It is also
possible to pass negative values.
For the copy operation to succeed, target has to be of the same type
than this slot.

If any index is out of range, an exception is thrown.

Note: If this method is used to copy values within the same slot then
the target range shouldn't currently overlap with the source slice.
\end{methoddesc}

% isSlotCompatible
\begin{methoddesc}{isSlotCompatible}{slot}
Return \code{True} if \var{slot} is compatible with this slot. Two slots are
compatible if they hold the same type of value. Only compatible slots can be
connected to each other. But note that even when this method returns
true, it can happen that the slots can {\it not} be connected. This is the
case whenever the target just doesn't accept input connections (for
example, because it's computing its output value procedurally).
\end{methoddesc}

% typeName
\begin{methoddesc}{typeName}{}
Return a string containing the name of the stored type. This name can
be used to display the type of the slot to the user. The name should
be chosen so that if two slots cannot be connected to each other then
they should also return different names (however, if two slots have
different names it is still possible that they can be connected to each
other).
\end{methoddesc}

% getController
\begin{methoddesc}{getController}{}
Return the associated controlling slot or \code{None}.
\end{methoddesc}

% setController
\begin{methoddesc}{setController}{slot}
Set or remove a controller for this slot.  The current controller is
replaced with \var{slot} which may also be \code{None} to remove the
current controller only. If the controller is not compatible with this
slot an \exception{EIncompatibleSlotTypes} exception is thrown. 
\end{methoddesc}

% getValue
\begin{methoddesc}{getValue}{index}
Return one item of the array slot. If the multiplicity of the slot is 1
then return value is just an individual value, otherwise it's a tuple
containing the values.
\end{methoddesc}

% setValue
\begin{methoddesc}{setValue}{index, value}
Set one item to a new value. If the multiplicity of the slot is 1 \var{value}
has to be one single value, otherwise it must be a sequence containing
\var{multiplicity} elements.
\end{methoddesc}

% connect
\begin{methoddesc}{connect}{slot}
Connect the output of this slot with the input of \var{slot}.
Calling this method is equivalent to calling \code{slot.setController(self)}.
\end{methoddesc}

% addDependent
\begin{methoddesc}{addDependent}{d}
Establish a dependency between this slot and another object \var{d}.
The argument \var{d} is added to the list of dependent objects. This
means that \var{d} somehow depends on the value of this slot and that
\var{d} has to be notified whenever the value of this slot changes.
The actual notification is done by calling \method{notifyDependents()}
which in turn calls \method{onValueChanged()} on all dependent objects.

Todo: C++ warning!
\end{methoddesc}

% removeDependent
\begin{methoddesc}{removeDependent}{d}
Remove the dependency between this slot and another object \var{d}.
\end{methoddesc}

% notifyDependents
%\begin{methoddesc}{notifyDependents}{}
%Notify all dependent slots about a value change. This method calls the
%\method{onValueChanged()} method of all slots whose value depends on the 
%value of this slot.
%\end{methoddesc}

% -------------------------------------------------
\subsection{SizeConstraint objects}
\label{sizeconstraints}

\class{SizeConstraint} objects can be passed into the constructor of
an array slot to constrain its size. There are two variants, the
\class{LinearSizeConstraint} and the \class{UserSizeConstraint}.
The former constrains an array slot to a size that linearly depends
on the size of another array slot, whereas the latter receives its
size from the user.

% LinearSizeConstraint
\begin{classdesc}{LinearSizeConstraint}{ctrlslot, a=1, b=0}
This class depends its size linearly on the size of another slot.

\var{ctrlslot} is an array slot whose size determines the size of the
constraint.

\var{a} and \var{b} are two coefficients that are used to calculate
the constraint size which is $a \cdot s + b$ where s is the size
of \var{ctrlslot}.
\end{classdesc}

% getCoeffs
\begin{methoddesc}{getCoeffs}{}
Returns a tuple (\var{a}, \var{b}) with the current coefficients.
\end{methoddesc}

% setCoeffs
\begin{methoddesc}{setCoeffs}{a, b}
Set new coefficients for the constraint. The operation might raise an
exception if the new coefficients are not compatible with another
constraint. In this case, the old coefficients remain active.
\end{methoddesc}


% UserSizeConstraint
\begin{classdesc}{UserSizeConstraint}{size=0}
This class stores a size that can be manually set by the user.

\var{size} is the initial size of the constraint.
\end{classdesc}

% setSize
\begin{methoddesc}{setSize}{size}
Set a new constraint size. All slots that are constrained by this object
will be resized. Note that the operation might fail and an exception is
thrown when the resize operation is not allowed (usually because there
are other slots involved that are also size constrained).
\end{methoddesc}


% -------------------------------------------------
\subsection{Procedural slots}

There are the following standard procedural slots:

\begin{itemize}
\item ProceduralDoubleSlot
\item ProceduralIntSlot
\item ProceduralVec3Slot
\item ProceduralVec4Slot
\item ProceduralMat3Slot
\item ProceduralMat4Slot
\item ProceduralQuatSlot
\end{itemize}

% -------------------------------------------------
\subsection{NotificationForwarder class}

A \class{NotificationForwarder} object can be used to forward slot
events from one particular slot to an arbitrary method instead of
the \method{onValueChanged()} or \method{onResize()} method.
To accomplish this the \class{NotificationForwarder} object is
added as a dependent object of the slot. This means, whenever
the value of the slot changes, the \method{onValueChanged()} method
of the \class{NotificationForwarder} object is called which in turn
calls an arbitrary other function or method.

\begin{classdesc}{NotificationForwarder}{onvalchanged, onresize=None}

\var{onvalchanged} is an arbitrary callable object that is invoked whenever a
{\em value changed} event has occured. If the forwarder is used with
a normal slot, the callable does not take any arguments. If it is used
with an array slot, it takes two arguments \var{start} and \var{end} that
specify what range has been modified.

\var{onresize} is a callable that gets called whenever the size of an
array slot has changed. It takes one argument which is the new size of the
slot.
\end{classdesc}

Example:

\begin{verbatim}
>>> from cgkit import *
>>> def myCallback(): print "Something has happened"
...
>>> s=Sphere()
>>> n=NotificationForwarder(myCallback)
>>> s.radius_slot.addDependent(n)
Something has happened
>>> s.radius=5
Something has happened
>>> s.radius=2
Something has happened  
\end{verbatim}
