\section{\module{cri} ---
         RenderMan binding for direct access to a renderer}

\declaremodule{extension}{cgkit.cri}
\modulesynopsis{RenderMan binding for direct access to a renderer}

The \module{cri} module is an alternative version of the \refmodule[cgkit.ri]{ri} module
that uses the Python \module{ctypes} module to interface a renderer directly.
The \module{ctypes} module is a foreign function library that is part of the
standard Python libraries since Python 2.5\footnote{Python 2.5 is embedded in
Maya 2008 and Houdini 9, whereas Maya 8.5 still uses Python 2.4.}.
With previous versions of Python, the module has to be installed separately. The module can be used in combination with any renderer
that implements the RenderMan API in a shared library. Using this module instead of 
the \module{ri} module has a number of advantages:

\begin{itemize}
\item You can mix Python code and C/C++ code and
issue RenderMan commands from any language into the same stream.
\item You can feed the renderer directly without having to create an
intermediate RIB. This also means you can use Python functions for
procedurals, filter functions or error handlers.
\item Even when generating RIB using this module is usually faster as the
actual RIB export is done by C/C++ code. The code is considerably faster if
you are using ctypes arrays or numpy arrays in your parameter lists. In this
case, no data conversion is required.
\end{itemize}

The disadvantage of using this module is that it depends on an external
dynamic library that must implement the actual functionality. This means if you
have not installed a renderer that ships with such a library you cannot use the
module.

Before any RenderMan function can be used, a library has to be loaded using
the \function{loadRI()} function. The returned module-like object can then be
used just like the \refmodule[cgkit.ri]{ri} module. 

% loadRI
\begin{funcdesc}{loadRI}{libName}
Load a RenderMan library and return a module-like handle to it.    
\var{libName} is the name of a shared library that implements the RenderMan
interface. The name can either be an absolute file name or just the
name of the library (without suffix or "lib" prefix) in which case the
function tries to find the library file itself. The return value is
an object that can be used like a module, i.e. it contains all RenderMan
functions, constants, etc.
If \var{libName} is \code{None} or the empty string, the return value is
just a reference to the \module{ri} module.

\begin{verbatim}
import cgkit.cri

ri = cgkit.cri.loadRI("3delight")

ri.RiBegin(ri.RI_NULL)
ri.RiWorldBegin()
ri.RiSurface("plastic")
ri.RiSphere(1,-1,1,360)
ri.RiWorldEnd()
ri.RiEnd()
\end{verbatim}

The RenderMan function names can either be used with or without the
"Ri" prefix. So the following is equivalent to the above:

\begin{verbatim}
ri.Begin(ri.RI_NULL)
ri.WorldBegin()
ri.Surface("plastic")
ri.Sphere(1,-1,1,360)
ri.WorldEnd()
ri.End()
\end{verbatim}

The following table lists the library names for some renderers that are known to
work with this module:

\begin{tableii}{l|c}{textrm}{Renderer}{Library Name}
\lineii{3Delight}{\code{3delight}}
\lineii{Aqsis}{\code{aqsislib} / \code{ri2rib}}
\lineii{Pixie}{\code{ri}}
\end{tableii}

PRMan (up to v13.5) only ships with a static library which is why it cannot be
used with this module.

\end{funcdesc}

% importRINames
\begin{funcdesc}{importRINames}{ri, ns}
Import the RenderMan names into the given namespace.
\var{ri} is the module-like object that was returned by \function{loadRI()}
and \var{ns} is a dictionary containing a module namespace (such as 
\function{globals()}) that will receive the "imported" symbols. Only
the names with the "Ri" prefix will be available. Example:

\begin{verbatim}
ri = cgkit.cri.loadRI("3delight")
cgkit.cri.importRINames(ri, globals())

RiBegin(RI_NULL)
RiWorldBegin()
RiSurface("plastic")
RiSphere(1,-1,1,360)
RiWorldEnd()
RiEnd()
\end{verbatim}
\end{funcdesc}

\subsection{Example}

The following example renders three Koch curves that form sort of a ``snowflake''
shape. Each curve is created by a procedural which just uses a regular Python
function as subdivide function. No RIB is generated by this example.\\
It is possible to create the same image using the generic \module{ri} module,
but the procedural would have to be written as a separate Python script that is
invoked using the ``RunProgram'' procedural. The code would actually be longer
because you would have to encode/decode the parameters of the procedural as
strings whereas this example directly passes vector objects around.

\begin{verbatim}
# Render a Koch snowflake as procedurals

import cgkit.cri
from cgkit.cgtypes import *

def bound(A, E):
    """Compute the bounding box of one segment."""
    eps = 0.03
    dv = E-A
    n = vec3(-dv.y, dv.x, 0)
    C = 0.5*(A+E) + 0.2887*n
    xx = [A.x, C.x, E.x]
    yy = [A.y, C.y, E.y]
    bound = [min(xx)-eps, max(xx)+eps, min(yy)-eps, max(yy)+eps, -0.001, 0.001]
    return bound

def subdiv(data, detail):
    """Subdivide function."""
    A,E = data
    dv = E-A
    if dv.length()<0.005:
        RiCurves(RI_LINEAR, [2], RI_NONPERIODIC, P=[A,E], constantwidth=0.003)
    else:
        t = 1.0/3
        B = (1.0-t)*A + t*E
        D = (1.0-t)*E + t*A
        n = vec3(-dv.y, dv.x, 0)
        C = 0.5*(A+E) + 0.2887*n
        RiProcedural((A,B), bound(A,B), subdiv)
        RiProcedural((B,C), bound(B,C), subdiv)
        RiProcedural((C,D), bound(C,D), subdiv)
        RiProcedural((D,E), bound(D,E), subdiv)

# Load the RenderMan API.
# Replace the library name with whatever renderer you want to use.
ri = cgkit.cri.loadRI("3delight")
cgkit.cri.importRINames(ri, globals())

RiBegin(RI_NULL)
RiFormat(1024,768,1)
RiDisplay("koch.tif", RI_FRAMEBUFFER, RI_RGB)
RiPixelSamples(3,3)
RiProjection(RI_ORTHOGRAPHIC)
RiScale(vec3(0.8))
RiTranslate(0,0.55,5)
RiWorldBegin()
RiSurface("constant")
RiColor((1,1,1))
RiPatch(RI_BILINEAR, P=[-2,2,1, 2,2,1, -2,-2,1, 2,-2,1])
RiColor((0,0,0))
RiProcedural((vec3(-1,0,0),vec3(1,0,0)), [-2,2, -2,2, -0.01,0.01], subdiv)
RiProcedural((vec3(0,-1.732,0),vec3(-1,0,0)), [-2,2, -2,2, -0.01,0.01], subdiv)
RiProcedural((vec3(1,0,0), vec3(0,-1.732,0)), [-2,2, -2,2, -0.01,0.01], subdiv)
RiWorldEnd()
RiEnd()
\end{verbatim}

Running the above example produces this image:

\begin{center}
\includegraphics[width=12cm]{pics/koch}
\end{center}

